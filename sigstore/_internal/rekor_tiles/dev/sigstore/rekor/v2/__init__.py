# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: dsse.proto, entry.proto, hashedrekord.proto, rekor_service.proto, verifier.proto
# plugin: python-betterproto
# This file has been @generated

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from dataclasses import dataclass
else:
    from pydantic.dataclasses import dataclass

from typing import (
    Dict,
    List,
    Optional,
)

import betterproto
import betterproto.lib.pydantic.google.protobuf as betterproto_lib_pydantic_google_protobuf
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase
from pydantic import model_validator
from pydantic.dataclasses import rebuild_dataclass

from .....google import api as ____google_api__
from .....io import intoto as ____io_intoto__
from ...common import v1 as __common_v1__
from .. import v1 as _v1__


@dataclass(eq=False, repr=False)
class PublicKey(betterproto.Message):
    """PublicKey contains an encoded public key"""

    raw_bytes: bytes = betterproto.bytes_field(1)
    """DER-encoded public key"""


@dataclass(eq=False, repr=False)
class Verifier(betterproto.Message):
    """
    Either a public key or a X.509 cerificiate with an embedded public key
    """

    public_key: Optional["PublicKey"] = betterproto.message_field(
        1, optional=True, group="verifier"
    )
    """
    DER-encoded public key. Encoding method is specified by the key_details attribute
    """

    x509_certificate: Optional["__common_v1__.X509Certificate"] = (
        betterproto.message_field(2, optional=True, group="verifier")
    )
    """DER-encoded certificate"""

    key_details: "__common_v1__.PublicKeyDetails" = betterproto.enum_field(3)
    """Key encoding and signature algorithm to use for this key"""

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


@dataclass(eq=False, repr=False)
class Signature(betterproto.Message):
    """A signature and an associated verifier"""

    content: bytes = betterproto.bytes_field(1)
    verifier: "Verifier" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class HashedRekordRequestV002(betterproto.Message):
    """A request to add a hashedrekord to the log"""

    digest: bytes = betterproto.bytes_field(1)
    """The hashed data"""

    signature: "Signature" = betterproto.message_field(2)
    """
    A single signature over the hashed data with the verifier needed to validate it
    """


@dataclass(eq=False, repr=False)
class HashedRekordLogEntryV002(betterproto.Message):
    data: "__common_v1__.HashOutput" = betterproto.message_field(1)
    """The hashed data"""

    signature: "Signature" = betterproto.message_field(2)
    """
    A single signature over the hashed data with the verifier needed to validate it
    """


@dataclass(eq=False, repr=False)
class DsseRequestV002(betterproto.Message):
    """A request to add a DSSE entry to the log"""

    envelope: "____io_intoto__.Envelope" = betterproto.message_field(1)
    """A DSSE envelope"""

    verifiers: List["Verifier"] = betterproto.message_field(2)
    """
    All necessary verification material to verify all signatures embedded in the envelope
    """


@dataclass(eq=False, repr=False)
class DsseLogEntryV002(betterproto.Message):
    payload_hash: "__common_v1__.HashOutput" = betterproto.message_field(1)
    """The hash of the DSSE payload"""

    signatures: List["Signature"] = betterproto.message_field(2)
    """
    Signatures and their associated verification material used to verify the payload
    """


@dataclass(eq=False, repr=False)
class Entry(betterproto.Message):
    """
    Entry is the message that is canonicalized and uploaded to the log.
     This format is meant to be compliant with Rekor v1 entries in that
     the `apiVersion` and `kind` can be parsed before parsing the spec.
     Clients are expected to understand and handle the differences in the
     contents of `spec` between Rekor v1 (a polymorphic OpenAPI defintion)
     and Rekor v2 (a typed proto defintion).
    """

    kind: str = betterproto.string_field(1)
    api_version: str = betterproto.string_field(2)
    spec: "Spec" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class Spec(betterproto.Message):
    """Spec contains one of the Rekor entry types."""

    hashed_rekord_v0_0_2: Optional["HashedRekordLogEntryV002"] = (
        betterproto.message_field(1, optional=True, group="spec")
    )
    dsse_v0_0_2: Optional["DsseLogEntryV002"] = betterproto.message_field(
        2, optional=True, group="spec"
    )

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


@dataclass(eq=False, repr=False)
class CreateEntryRequest(betterproto.Message):
    """Create a new HashedRekord or DSSE"""

    hashed_rekord_request_v0_0_2: Optional["HashedRekordRequestV002"] = (
        betterproto.message_field(1, optional=True, group="spec")
    )
    dsse_request_v0_0_2: Optional["DsseRequestV002"] = betterproto.message_field(
        2, optional=True, group="spec"
    )

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


@dataclass(eq=False, repr=False)
class TileRequest(betterproto.Message):
    """
    Request for a full or partial tile (see https://github.com/C2SP/C2SP/blob/main/tlog-tiles.md#merkle-tree)
    """

    l: int = betterproto.uint32_field(1)
    n: str = betterproto.string_field(2)
    """
    N must be either an index encoded as zero-padded 3-digit path elements, e.g. "x123/x456/789",
     and may end with ".p/<W>", where "<W>" is a uint8
    """


@dataclass(eq=False, repr=False)
class EntryBundleRequest(betterproto.Message):
    """
    Request for a full or partial entry bundle (see https://github.com/C2SP/C2SP/blob/main/tlog-tiles.md#log-entries)
    """

    n: str = betterproto.string_field(1)
    """
    N must be either an index encoded as zero-padded 3-digit path elements, e.g. "x123/x456/789",
     and may end with ".p/<W>", where "<W>" is a uint8
    """


class RekorStub(betterproto.ServiceStub):
    async def create_entry(
        self,
        create_entry_request: "CreateEntryRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "_v1__.TransparencyLogEntry":
        return await self._unary_unary(
            "/dev.sigstore.rekor.v2.Rekor/CreateEntry",
            create_entry_request,
            _v1__.TransparencyLogEntry,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_tile(
        self,
        tile_request: "TileRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "____google_api__.HttpBody":
        return await self._unary_unary(
            "/dev.sigstore.rekor.v2.Rekor/GetTile",
            tile_request,
            ____google_api__.HttpBody,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_entry_bundle(
        self,
        entry_bundle_request: "EntryBundleRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "____google_api__.HttpBody":
        return await self._unary_unary(
            "/dev.sigstore.rekor.v2.Rekor/GetEntryBundle",
            entry_bundle_request,
            ____google_api__.HttpBody,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_checkpoint(
        self,
        betterproto_lib_pydantic_google_protobuf_empty: "betterproto_lib_pydantic_google_protobuf.Empty",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "____google_api__.HttpBody":
        return await self._unary_unary(
            "/dev.sigstore.rekor.v2.Rekor/GetCheckpoint",
            betterproto_lib_pydantic_google_protobuf_empty,
            ____google_api__.HttpBody,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class RekorBase(ServiceBase):
    async def create_entry(
        self, create_entry_request: "CreateEntryRequest"
    ) -> "_v1__.TransparencyLogEntry":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_tile(
        self, tile_request: "TileRequest"
    ) -> "____google_api__.HttpBody":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_entry_bundle(
        self, entry_bundle_request: "EntryBundleRequest"
    ) -> "____google_api__.HttpBody":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_checkpoint(
        self,
        betterproto_lib_pydantic_google_protobuf_empty: "betterproto_lib_pydantic_google_protobuf.Empty",
    ) -> "____google_api__.HttpBody":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_create_entry(
        self,
        stream: "grpclib.server.Stream[CreateEntryRequest, _v1__.TransparencyLogEntry]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.create_entry(request)
        await stream.send_message(response)

    async def __rpc_get_tile(
        self, stream: "grpclib.server.Stream[TileRequest, ____google_api__.HttpBody]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_tile(request)
        await stream.send_message(response)

    async def __rpc_get_entry_bundle(
        self,
        stream: "grpclib.server.Stream[EntryBundleRequest, ____google_api__.HttpBody]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_entry_bundle(request)
        await stream.send_message(response)

    async def __rpc_get_checkpoint(
        self,
        stream: "grpclib.server.Stream[betterproto_lib_pydantic_google_protobuf.Empty, ____google_api__.HttpBody]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_checkpoint(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/dev.sigstore.rekor.v2.Rekor/CreateEntry": grpclib.const.Handler(
                self.__rpc_create_entry,
                grpclib.const.Cardinality.UNARY_UNARY,
                CreateEntryRequest,
                _v1__.TransparencyLogEntry,
            ),
            "/dev.sigstore.rekor.v2.Rekor/GetTile": grpclib.const.Handler(
                self.__rpc_get_tile,
                grpclib.const.Cardinality.UNARY_UNARY,
                TileRequest,
                ____google_api__.HttpBody,
            ),
            "/dev.sigstore.rekor.v2.Rekor/GetEntryBundle": grpclib.const.Handler(
                self.__rpc_get_entry_bundle,
                grpclib.const.Cardinality.UNARY_UNARY,
                EntryBundleRequest,
                ____google_api__.HttpBody,
            ),
            "/dev.sigstore.rekor.v2.Rekor/GetCheckpoint": grpclib.const.Handler(
                self.__rpc_get_checkpoint,
                grpclib.const.Cardinality.UNARY_UNARY,
                betterproto_lib_pydantic_google_protobuf.Empty,
                ____google_api__.HttpBody,
            ),
        }


rebuild_dataclass(Verifier)  # type: ignore
rebuild_dataclass(Signature)  # type: ignore
rebuild_dataclass(HashedRekordRequestV002)  # type: ignore
rebuild_dataclass(HashedRekordLogEntryV002)  # type: ignore
rebuild_dataclass(DsseRequestV002)  # type: ignore
rebuild_dataclass(DsseLogEntryV002)  # type: ignore
rebuild_dataclass(Entry)  # type: ignore
rebuild_dataclass(Spec)  # type: ignore
rebuild_dataclass(CreateEntryRequest)  # type: ignore
